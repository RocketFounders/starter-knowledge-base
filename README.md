# Методическое пособие инженера Rocket Founders

## Содержание


### 1. **Онбоардинг. Подготовка к работе**
### 2. **Workflow. Работа над проектом**

  
#### Глава 1. Введение

- 1.1. **Описание раздела.**
- 1.2. **Обзор структуры раздела и основных тем, которые будут рассмотрены.**
- 1.3. **Подчеркивание важности понимания всего процесса разработки для успешного участия в проекте.**
- 1.4. **Уточнение целей и задач, которые джун должен выполнить в рамках этого раздела.**

#### Глава 2.  Работа с Git и первый комит
- 2.1. **Как внести изменения и закоммитить их**
- 2.2. **Как отправить запрос на включение изменений (Pull Request)**

  
#### Глава 3. Работа с базой данных
- 3.1. **Запись данных в базу данных PostgreSQL.**
- 3.2. **Создание и применение миграций данных для изменения структуры базы данных.**


#### Глава 4. Работа на серверной стороне
- 4.1. **Настройка и интеграция FastAPI для создания API endpoint'ов и обработки данных на бэкенде.**
- 4.2. **Тестирование и отладка API endpoint'ов, взаимодействие с базой данных и другими компонентами.**


#### Глава 5. Работа на клиентской стороне
- 5.1. **Настройка и интеграция Next.js для обращения к API на бэкенде, обработки данных и отображения их на фронтенде.**


#### Глава 6. Тестирование и отладка
- 6.1. **Тестирование API.**
- 6.2. **компонентов на фронтенде.**
- 6.3 **Анализ логов.**

  
#### Глава 7. Завершение работы

- 7.1. **Коммит изменений в созданную ветку Git с описанием проделанной работы.**
- 7.2. **Описание процесса деплоя проекта и внесенных изменений, включая настройку среды разработки и деплоя, создание Docker образов и настройку CI/CD.**
- 7.3. **Предоставление рекомендаций по тестированию и обслуживанию развернутой версии приложения.**

  

### 3. **FAQ. Дерево решений**
  

# Методическое пособие инженера Rocket Founders
## 1. **Онбоардинг. Подготовка к работе**
### Установка и настройка необходимого программного обеспечения

  
1.  **Git** [Инструкция](https://habr.com/ru/articles/588801/)
-  **Windows:** Скачайте и установите Git с официального сайта [git-scm.com](https://git-scm.com/download/win).
-  **Linux:** Установите Git через менеджер пакетов вашего дистрибутива, например, для Ubuntu: `sudo apt-get install git`.
-  **MacOS:** Git обычно предустановлен на MacOS. Если нет, можно установить через Homebrew: `brew install git`.

  

2.  **PostgreSQL** [Инструкция](https://wiki.postgresql.org/wiki/Detailed_installation_guides)
-  **Windows:** Скачайте и установите PostgreSQL с официального сайта [postgresql.org](https://www.postgresql.org/download/windows/).
-  **Linux:** Установите PostgreSQL через менеджер пакетов, например, для Ubuntu: `sudo apt-get install postgresql`.
-  **MacOS:** Установите PostgreSQL с помощью Homebrew: `brew install postgresql`.
  

3.  **Redis** [Инструкция](https://www.devglan.com/blog/install-redis-windows-and-mac)
-  **Windows:** Скачайте и установите Redis с официального сайта [redis.io](https://redis.io/download).
-  **Linux:** Установите Redis через менеджер пакетов, например, для Ubuntu: `sudo apt-get install redis-server`.
-  **MacOS:** Установите Redis с помощью Homebrew: `brew install redis`.

  
4.  **Docker** [Инструкция](https://gist.github.com/rstacruz/297fc799f094f55d062b982f7dac9e41)
-  **Windows:** Скачайте и установите Docker Desktop с официального сайта [docker.com](https://www.docker.com/products/docker-desktop).
-  **Linux:** Установите Docker Engine через менеджер пакетов вашего дистрибутива, следуя инструкциям на [docker.com](https://docs.docker.com/engine/install/).
-  **MacOS:** Установите Docker Desktop с официального сайта [docker.com](https://www.docker.com/products/docker-desktop).

  
5.  **Golang-migrate**
-  **Windows:** Скачайте исполняемый файл migrate.exe с GitHub репозитория [github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate/releases) и добавьте его в переменную среды PATH.
-  **Linux и MacOS:** Установите golang-migrate с помощью Go:
```bash
go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
```

  
6.  **PyCharm и WebStorm**
- Скачайте и установите PyCharm и/или WebStorm с официального сайта [jetbrains.com](https://www.jetbrains.com/).
  

### Клонирование репозитория Git и подключение к нему

Склонируйте  репозиторий на свой компьютер:
	- Через консольную команду: `git  clone  <ссылка на репозиторий>.git`
	- Или откройте PyCharm или WebStorm и выберите "Check out from Version Control" -> "Git". Введите URL репозитория и нажмите "Clone".
    
### Обзор файловой структуры проекта

Перед тем как мы начнем работу, давайте взглянем на структуру файлов нашего проекта. Основная структура файлового дерева для проектов на FastAPI и Next.js представляет собой следующее:

*FastAPI проект:*

```bash

**.**

├── LICENSE

├── Makefile

├── README.md

├── config.py

├── **core**

│ ├── __init__.py

│ ├── **api**

│ │ ├── __init__.py

│ │ ├── **auth**

│ │ │ ├── __init__.py

│ │ │ └── handlers.py

│ │ ├── **ping**

│ │ │ ├── __init__.py

│ │ │ └── handlers.py

│ │ └── **profile**

│ │ ├── __init__.py

│ │ └── handlers.py

│ ├── **helpers**

│ │ └── **auth**

│ ├── **model**

│ │ └── **profile**

│ │ ├── **db**

│ │ ├── **enums**

│ │ ├── **requests**

│ │ └── **responses**

│ ├── **models**

│ │ ├── __init__.py

│ │ ├── **auth**

│ │ │ ├── __init__.py

│ │ │ ├── domains.py

│ │ │ ├── enums.py

│ │ │ ├── requests.py

│ │ │ └── responses.py

│ │ └── **profile**

│ │ ├── __init__.py

│ │ ├── db.py

│ │ ├── domains.py

│ │ ├── enums.py

│ │ ├── requests.py

│ │ └── responses.py

│ ├── registry.py

│ ├── **services**

│ │ ├── __init__.py

│ │ ├── **auth**

│ │ │ ├── __init__.py

│ │ │ └── services.py

│ │ └── **profile**

│ │ ├── __init__.py

│ │ ├── helpers.py

│ │ └── services.py

│ ├── **storage**

│ │ ├── __init__.py

│ │ ├── **db**

│ │ │ ├── postgres.py

│ │ │ └── schema.sql

│ │ ├── ping_storage.py

│ │ └── profile_storage.py

│ ├── **tasks**

│ │ ├── __init__.py

│ │ └── task_list.py

│ └── utils.py

├── docker-compose.yml

├── logging.conf

├── main.py

├── poetry.lock

├── pyproject.toml

└── **tests**

├── __init__.py

├── conftest.py

└── **utils**

├── __init__.py

└── request.py

  

25 directories, 48 files

```

*Next.js проект:*

```bash
├── LICENSE

├── README.md

├── **actions**

│ └── profile.js

├── **app**

│ ├── **authenticated**

│ │ └── page.js

│ ├── layout.js

│ ├── **login**

│ │ └── page.js

│ ├── page.js

│ ├── **profile**

│ │ └── page.js

│ ├── **register**

│ │ └── page.js

│ └── **restore**

│ └── page.js

├── **components**

│ ├── **common**

│ │ ├── BaseLayout.js

│ │ ├── Footer.js

│ │ ├── Navbar.js

│ │ └── ProfileCard.js

│ └── **pages**

│ ├── **authenticated**

│ │ └── AuthenticatedPage.js

│ ├── **home**

│ │ └── Home.js

│ ├── **login**

│ │ └── Login.js

│ ├── **profile**

│ │ └── Profile.js

│ ├── **register**

│ │ └── Register.js

│ └── **restore**

│ └── Restore.js

├── **deploy**

│ ├── Dockerfile

│ └── docker-compose.yml

├── jsconfig.json

├── next.config.js

├── package-lock.json

├── package.json

├── **plugins**

│ └── axios.js

├── **public**

│ ├── **assets**

│ │ └── logo.jpeg

│ ├── **css**

│ │ ├── global.css

│ │ ├── mobile.css

│ │ └── style.css

│ ├── **fonts**

│ └── **scripts**

├── **schemas**

│ └── **profile**

│ └── index.js

├── **services**

│ └── profile.js

├── **store**

│ └── index.js

├── **utils**

│ └── profile.js

└── yarn.lock

  

29 directories, 36 files

```

Эта структура позволяет организовать проект таким образом, чтобы каждая его часть была легко доступна и понятна для разработчика. Разделяя файлы по функциональности и типу, мы упрощаем поддержку и масштабирование проекта.

  

### Обзор Makefile

Запуск некоторых основных команд, происходит через Makefile.


Makefile - это текстовый файл, который содержит набор инструкций (целей) для автоматизации процесса сборки и управления проектом. В данном случае Makefile используется для управления процессом разработки веб-приложения.


Краткий обзор Makefile:
  

1.  `include .env` - подключает файл .env для загрузки переменных окружения.
2.  `export` - экспортирует переменные окружения из .env файла.
3.  `new_migration` - цель для создания новой миграции базы данных. Она запрашивает у пользователя имя новой миграции, а затем использует инструмент миграции (возможно, это Alembic) для создания новой миграции SQL файла в директории ./core/storage/db/migrations.
4.  `migrate` - цель для применения миграций базы данных. Она использует переменную ${DATABASE_URL}, чтобы подключиться к базе данных и применить миграции, которые были созданы ранее.
5.  `uvicorn_start` - цель для запуска приложения с помощью uvicorn. Она использует poetry для запуска uvicorn, указывая файл main.py в качестве точки входа в приложение.

Этот Makefile упрощает процесс создания и применения миграций базы данных, а также запуска приложения, делая процесс разработки более автоматизированным и удобным.

### Настройка переменных окружения

Установите переменные окружения, создав файл .env и добавив необходимые переменные. Эти переменные предоставляют важные настройки для работы приложения, такие как подключение к базе данных, управление сессиями и безопасностью. Вот небольшое описание каждой из них:

- `ENV`: Определяет окружение, в котором работает приложение. В данном случае установлено значение "LOCAL", что указывает на локальное окружение разработки.
- `VERSION`: Указывает на версию приложения. В данном случае установлено значение "0.1".
- `DATABASE_URL`: URL для подключения к базе данных PostgreSQL. Обычно включает в себя информацию о протоколе, имени хоста, порту и названии базы данных.
- `DB_DBNAME`: Имя базы данных PostgreSQL, к которой приложение должно подключаться.
- `DB_USERNAME`: Имя пользователя PostgreSQL для доступа к базе данных.
- `DB_PASSWORD`: Пароль пользователя PostgreSQL для доступа к базе данных.
- `DB_PORT`: Порт, на котором работает база данных PostgreSQL.
- `SECRET_KEY`: Секретный ключ, используемый для шифрования данных и создания безопасных токенов сессии.
- `ACCESS_TOKEN_EXPIRE_DAYS`: Время жизни доступного токена в днях. Указывает, через сколько дней токен станет недействительным и потребуется повторная аутентификация.


### Настройка пользователя и базы данных PostgreSQL. Подключение к БД

1. Создание пользователя в PostgreSQL


Чтобы создать пользователя в PostgreSQL, следуйте этим шагам:
1.  **Windows:**
- Откройте командную строку от имени администратора.
- Войдите в консоль PostgreSQL, выполнив команду: `psql -U postgres`.
- Создайте пользователя с помощью команды:
```sql
CREATE USER myuser WITH  PASSWORD  'mypassword';
```

2.  **Linux и MacOS:**

- Откройте терминал и выполните команду для входа в консоль PostgreSQL:
```bash
sudo -u postgres psql
```
- Создайте пользователя с помощью SQL-запроса:
```sql
CREATE USER myuser WITH  PASSWORD  'mypassword';
```
Где:
-  `myuser` - имя нового пользователя.
-  `mypassword` - пароль для нового пользователя.

После создания пользователя, вы можете предоставить ему необходимые привилегии, например, разрешение на подключение к базе данных и выполнение операций чтения/записи в ней.


2.  **Настройка базы данных PostgreSQL**

-  **Windows:**
- Запустите командную строку от имени администратора.
- Войдите в консоль PostgreSQL, выполнив команду: `psql -U myuser`.
- Создайте базу данных: `CREATE DATABASE my_database;`.
-  **Linux и MacOS:**
- Откройте терминал и выполните команды:
```bash
sudo -u myuser psql
CREATE DATABASE my_database;
```

3.  **Установка миграций**

- Запустите команду для установки миграций:
```bash
make migrate
```

3.  **Подключение к базе данных**
- Измените файл .env, установив значение DATABASE_URL в формате: `postgresql://myuser:mypassword@localhost:5432/my_database`
  

### Настройка рабочего окружения Python

1.  **Установка Pyenv**
- Следуйте инструкциям на официальной странице репозитория Pyenv: [github.com/pyenv/pyenv](https://github.com/pyenv/pyenv#installation).

2.  **Установка Poetry**
- Установите Poetry, выполнив команду:
```bash
curl -sSL https://install.python-poetry.org | python3  -
```

3.  **Установка Python 3.11**

- Установите Python 3.11 с помощью Pyenv:
```bash
pyenv install 3.11.4
pyenv global 3.11.4
```

4.  **Установка зависимостей Python**

- В корневой директории проекта выполните команду:
```bash
poetry install
```

### Настройка рабочего окружения Node.js  

1.  **Установка Node.js**
- Скачайте и установите Node.js с официального сайта [nodejs.org](https://nodejs.org/).

2. Установка зависимостей для проекта на Next.js
- Установите зависимости проекта Next.js: `npm install`
  

### Запуск проекта на Next.js
- Запустите проект с помощью команды: `npm run dev` или `yarn dev`
  
### Запуск FastApi проекта с помощью Makefile

- Запустите проект с помощью команды: `make uvicorn_start`


## 2. **Workflow. Работа над проектом**


### Глава 1. Введение
  

Добро пожаловать! Здесь мы начнем наше путешествие в мир разработки веб-приложений, основанное на нашем проекте-шаблоне. В этой главе мы расскажем о том, какой путь предстоит тебе пройти, чтобы успешно освоить рабочий процесс разработки.
  

##### 1.1. Описание раздела
  

Мы ставим перед собой задачу предоставить тебе полное понимание рабочего процесса разработки веб-приложений на примере нашего проекта-шаблона. Это позволит тебе не только овладеть конкретными навыками, но и понять весь цикл разработки от начала до конца. Это особенно важно для тебя, как джуниора-разработчика, чтобы ты мог стать более уверенным и компетентным специалистом.
  

##### 1.2. Обзор структуры раздела и основных тем
  

Мы разбили раздел на несколько этапов, каждый из которых описывает конкретный шаг в рабочем процессе разработки. Мы начнем с базовых вещей, таких как запись данных в базу данных, и двинемся к более сложным аспектам, таким как разработка API и методов на фронтенде. Это позволит тебе понять, как все компоненты приложения взаимодействуют между собой и какие задачи решаются на каждом этапе разработки.
  

##### 1.3. Подчеркивание важности понимания процесса разработки
  

Понимание всего процесса разработки от начала до конца является ключевым элементом успешной карьеры в сфере веб-разработки. Это поможет тебе не только эффективно выполнять свои задачи, но и лучше взаимодействовать с коллегами и понимать общую картину проекта.
  

##### 1.4. Цели и задачи раздела для джуна
  

В этом разделе мы ставим перед тобой ряд конкретных целей и задач, которые помогут тебе достичь определенных результатов и овладеть необходимыми навыками в процессе разработки веб-приложений. Вот основные цели и задачи, которые тебе предстоит выполнить
  

1. Освоить рабочий процесс разработки веб-приложений от начала до конца.

2. Научиться записывать данные в базу данных и взаимодействовать с ней через SQL и миграции данных.

3. Разработать и настроить API на серверной стороне с помощью FastAPI для обработки запросов и взаимодействия с базой данных.

4. Интегрировать и использовать Next.js на клиентской стороне для обращения к API, обработки данных и отображения их на пользовательском интерфейсе.

5. Научиться эффективно тестировать и отлаживать разрабатываемое приложение, а также анализировать логи для выявления ошибок.

6. Понять процесс деплоя приложения, включая настройку среды разработки, создание Docker образов и настройку CI/CD.

7. Получить представление о важности усвоения всего рабочего процесса для успешного участия в проекте и дальнейшего профессионального роста.

  
### Глава 2.  Работа с Git и первый комит

1.  **Форкните репозиторий**: Нажмите на кнопку "Fork" в верхнем правом углу страницы репозитория, чтобы создать копию в своем аккаунте.
    
2.  **Клонируйте репозиторий**: Склонируйте форкнутый репозиторий на свой компьютер:
	- Через консольную команду:  
	```bash 
	git  clone  https://github.com/ваш_логин/название_репозитория.git
	```
	- Или откройте PyCharm или WebStorm и выберите "Check out from Version Control" -> "Git". Введите URL репозитория и нажмите "Clone".
    
3.  **Создайте новую ветку**: Перейдите в директорию репозитория и создайте новую ветку для своих изменений:
    ```bash
    git checkout -b название_вашей_ветки
    ``` 
#### 2.1. Как внести изменения и закоммитить их:

1. **Внесите изменения**: Внесите необходимые изменения в код, добавьте новые файлы или удалите старые.

2. **Добавьте изменения для коммита**: Используйте `git add` для добавления измененных файлов в список отслеживаемых:
    ```bash
    git add .
    ```

3. **Закоммитьте изменения**: Закоммитьте изменения с понятным описанием:
    ```bash
    git commit -m "Описание ваших изменений"
    ```

4. **Отправьте изменения в свой форк**: Отправьте ваши изменения в ваш форк репозитория:
    ```bash
    git push origin название_вашей_ветки
    ```

#### 2.2. Как отправить запрос на включение изменений (Pull Request):

1. Перейдите на страницу вашего репозитория на Gitea.

2. Нажмите на кнопку "Compare & pull request" рядом с вашей веткой.

3. Убедитесь, что ваши изменения отображаются корректно и заполните информацию о запросе на включение изменений (PR).

4. Нажмите на кнопку "Create pull request", чтобы отправить ваш запрос.

После создания PR, ваши изменения будут рассмотрены и, при необходимости, внесены в основной репозиторий.

### Глава 3. Работа с базой данных
  

В этой главе мы погрузимся в мир баз данных и изучим основные операции с PostgreSQL. Мы рассмотрим, как записывать данные в базу данных вручную с использованием SQL-скриптов, а также как создавать и применять миграции данных для изменения структуры базы данных.
  

#### 3.1. Запись данных в базу данных PostgreSQL
  

Для начала работы с базой данных PostgreSQL, давайте убедимся, что она установлена и запущена на вашей системе. Затем мы можем использовать любой удобный для вас инструмент для работы с PostgreSQL, такой как командная строка (psql), pgAdmin или любой другой клиент.


Мы будем работать с базой данных PostgreSQL под пользователем "myuser".


1. Подключение к базе данных PostgreSQL под пользователем `myuser` и выбор базы данных `my_database`:


```bash
psql -U myuser -d my_database
```


После выполнения этой команды вы попадете в интерактивный интерфейс PostgreSQL, где сможете выполнять SQL-запросы.


2. Вывод списка существующих таблиц в базе данных:
  

```sql
\dt
```

Эта команда позволяет вывести список всех таблиц в текущей базе данных. Вы увидите названия таблиц и их схемы.

После раздела "Онбоардинг" у тебя уже должна быть создана таблица "api_profile" в твоей локальной базе данных.

Создадим таблицу "api_order", которая будет содержать информацию о заказах.

```sql

CREATE  TABLE  IF  NOT  EXISTS api_order (
	id SERIAL  PRIMARY KEY,
	profile_id VARCHAR(16) REFERENCES api_profile(id),
	product_name VARCHAR(100) NOT NULL,
	quantity INT  NOT NULL,
	price DECIMAL(10, 2) NOT NULL,
	created_at TIMESTAMP  DEFAULT CURRENT_TIMESTAMP
);

```

Теперь у нас есть таблица "api_order", которая будет использоваться для хранения информации о заказах. Обратите внимание, что в этой таблице есть внешний ключ "profile_id", который ссылается на таблицу "api_profile".
 

#### 3.2. Создание и применение миграций данных для изменения структуры базы данных.

Давайте рассмотрим различные операции с базой данных, начиная с создания записей в таблицах "api_profile" и "api_order".
  

##### Создание записей в таблицах "api_profile" и "api_order"
  

```sql

-- Создание профиля
INSERT INTO api_profile (id, username, password, email, phone_number)
VALUES ('pr_1234567890', 'john_doe', 'password123', 'john@example.com', '+1234567890');
  

-- Создание заказа
INSERT INTO api_order (profile_id, product_name, quantity, price)
VALUES ('pr_1234567890', 'Laptop', 1, 1500.00);

```

  

##### Добавление внешнего ключа

  

```sql

-- Добавление внешнего ключа
ALTER  TABLE api_order
ADD  CONSTRAINT fk_profile_id
FOREIGN KEY (profile_id)
REFERENCES api_profile(id);

```

  

##### Примеры CRUD запросов

  

```sql

-- Получение информации о заказах для конкретного профиля
SELECT * FROM api_order WHERE profile_id = 'pr_1234567890';

  
-- Получение информации о профилях и заказах с сортировкой
SELECT p.id AS profile_id, p.username, p.email, o.id AS order_id, o.product_name, o.quantity
FROM api_profile AS p
JOIN api_order AS o ON p.id = o.profile_id
ORDER BY p.username ASC, o.product_name ASC;

-- Обновление информации о заказе
UPDATE api_order SET quantity = 2 WHERE id = 1;

-- Удаление заказа
DELETE  FROM api_order WHERE id = 1;
```

Конечно, вот пример README.md файла с инструкциями о схеме базы данных:

---

#### 3.3. Инструкция по управлению схемой базы данных

В этом репозитории используется файл `schema.sql` для управления структурой базы данных. Пожалуйста, следуйте этим инструкциям при внесении изменений в схему базы данных.

##### Запись изменений схемы базы данных

Все изменения в структуре базы данных должны быть записаны в файл `schema.sql`. Этот файл содержит SQL-запросы для создания таблиц, индексов, ограничений и других объектов базы данных.

При добавлении новых таблиц, полей или индексов, а также при изменении существующих объектов базы данных, убедитесь, что соответствующие SQL-запросы добавлены или изменены в файле `schema.sql`.

##### Применение изменений к базе данных

Чтобы применить изменения схемы базы данных к вашей локальной или удаленной базе данных, выполните следующие шаги:

1. **Откройте файл `schema.sql`**: Откройте файл `schema.sql` в вашем текстовом редакторе или интегрированной среде разработки (IDE).

2. **Внесите необходимые изменения**: Внесите необходимые изменения в структуру базы данных, добавив, изменяя или удаляя объекты базы данных при необходимости.

3. **Сохраните изменения**: Сохраните файл `schema.sql` после внесения всех необходимых изменений.

4. **Примените изменения к базе данных**: Запустите скрипт `schema.sql` на вашей локальной или удаленной базе данных с помощью инструмента для управления базой данных (например, `psql` для PostgreSQL). Убедитесь, что скрипт выполняется без ошибок.

5. **Проверьте изменения**: Проверьте, что изменения успешно применены к базе данных, выполнив необходимые запросы SQL или проверив структуру базы данных с помощью инструментов администрирования баз данных.

### Глава 4. Работа на серверной стороне

#### 4.1. Создания API endpoint'ов и обработки данных на бэкенде.

  

#### Создание API endpoint'ов


Давайте создадим простой API endpoint для получения информации о профилях пользователей. Создайте новый файл `api.py` в папке `core`, если его еще нет, и добавьте следующий код:

  

```python

from fastapi import FastAPI

from core.models.profile import Profile

app = FastAPI()
  
@app.get("/profiles/{profile_id}")
async  def  read_profile(profile_id: str):
	# Здесь должен быть код для получения профиля по его ID из базы данных
	profile = Profile.get_by_id(profile_id)
	return {"profile_id": profile.id, "username": profile.username, "email": profile.email}

```


Этот код создает простой API endpoint для получения информации о профиле по его ID.
  
Вот пример README.md файла для FastAPI проекта с описанием кода бэкенда для вывода заказов по профилю и инструкциями по тестированию:

#### Запуск проекта

  
Теперь мы можем запустить наш проект FastAPI с помощью команды:
  

```bash
make  uvicorn_start
```

Теперь вы можете отправить GET-запрос по адресу `curl http://localhost:8000/profiles/{profile_id}` и получить информацию о профиле.

---

#### 4.2. Пример вывода заказов по профилю

##### Уровень стореджа (Storage)

- **`storage.py`**: Содержит функции для работы с базой данных, такие как создание, чтение, обновление и удаление заказов и других объектов.
```python
    
class ProfileStorage:  
    def __init__(self, db: DB) -> None:  
        self.db = db  
  
    async def get_profile_with_orders(  
            self, profile_id,
  ) -> list[ProfileDB]:  
        sql = "SELECT p.id AS profile_id, p.username, p.email, o.id AS order_id, o.product_name, o.quantity FROM api_profile AS p JOIN api_order AS o ON p.id = o.profile_id WHERE p.id=$1 ORDER BY p.username ASC, o.product_name ASC;"  
		rows = await self.db.fetch(sql, profile_id)  
        if not rows:  
            throw_not_found("No active users!")  
  
        profiles: list[ProfileDB] = []  
        for row in rows:  
            profiles.append(self.row_to_profile(row))  
  
        return profiles  

```

##### Уровень сервиса (Service)

- **`service.py`**: В этом модуле содержатся бизнес-логика и сервисы для работы с заказами, включая логику для получения заказов пользователя по его профилю.
```python
from typing import List
from .storage import get_profile_with_orders
from .models import ProfileDB

# Бизнес-логика и сервисы
def get_user_orders(profile_id: int) -> List[ProfileDB]:
    return get_profile_with_orders(profile_id)

```

##### Уровень хэндлера (Handler)

- **`api.py`**: Определяет маршруты API и связывает их с соответствующими функциями обработчиков. Включает обработчики для запросов на получение заказов пользователя.

```python
from main import app
from .service import get_user_orders
from .models import ProfileDB
from typing import List

@app.get("/user-orders", response_model=List[ProfileDB])
async def read_user_orders(user_id: int):
    orders = get_user_orders(user_id)
    return orders
```

#### Как протестировать, что ручка работает

1. **Установите зависимости**: Убедитесь, что все зависимости проекта установлены. Выполните команду:
    ```bash
    pip install -r requirements.txt
    ```

2. **Запустите сервер**: Запустите сервер FastAPI. В корневой директории проекта выполните команду:
    ```bash
    uvicorn main:app --reload
    ```

3. **Отправьте запрос на получение заказов пользователя**: Используйте любой HTTP-клиент (например, `curl` или инструменты для тестирования API, такие как Postman или Insomnia) для отправки запроса на получение заказов пользователя. Например:
    ```bash
    curl -X GET "http://localhost:8000/orders?user_id=123"
    ```

4. **Проверьте ответ**: Проверьте ответ от сервера и убедитесь, что он содержит ожидаемые данные заказов пользователя.
  

#### 4.3. Тестирование и отладка API endpoint'ов, взаимодействие с базой данных и другими компонентами.

FastAPI предоставляет инструменты для автоматического тестирования API endpoint'ов. Давайте напишем простой тест для нашего API endpoint'а:

```python

import requests

def test_read_profile():
	response = requests.get("http://localhost:8000/profiles/1")
	assert response.status_code == 200
	assert response.json()["username"] == "test_user"
```

Этот тест отправляет GET-запрос к нашему API endpoint'у и проверяет, что мы получаем ожидаемый ответ.

  
#### Отладка API endpoint'ов
 
Для отладки API endpoint'ов вы можете использовать инструменты, предоставляемые вашей средой разработки, такие как PyCharm или VSCode. Установите точки останова в вашем коде и запустите процесс отладки, чтобы шаг за шагом проходить через код и проверять его выполнение.


#### Взаимодействие с базой данных и другими компонентами
 
Для взаимодействия с базой данных вы можете использовать ORM, такой как SQLAlchemy, или использовать библиотеки для работы с базами данных напрямую, такие как asyncpg для асинхронных запросов к PostgreSQL.

  

```python

import asyncpg


async  def  get_profile_from_db(profile_id: str):
	conn = await asyncpg.connect(user='myuser', password='password', database='my_database', host='localhost')
	profile = await conn.fetchrow('SELECT * FROM api_profile WHERE id = $1', profile_id)
	await conn.close()
	return profile

```

  

Этот код показывает, как выполнить асинхронный запрос к базе данных PostgreSQL и получить профиль пользователя по его ID.

  

### Глава 5. Работа на клиентской стороне


#### 5.1. Настройка и интеграция Next.js

  

Для интеграции с нашим бэкендом мы будем использовать API эндпоинты, которые мы создали ранее с помощью FastAPI.

  

Сначала создайте файл `api.js` в папке `pages/api` вашего проекта Next.js:

  

```javascript

// pages/api/api.js

export  default  async  function  handler(req, res) {
	const  response = await  fetch('http://localhost:8000/api/data');
	const  data = await  response.json();
	res.status(200).json(data);
}

```

  

Здесь мы создали API эндпоинт `/api/api`, который делает запрос к нашему бэкенду FastAPI по адресу `http://localhost:8000/api/data`.

  

#### 5.2. Получение и отображение данных на фронтенде

  

Теперь мы можем получить данные с нашего бэкенда через новый API эндпоинт в компонентах Next.js и отобразить их на фронтенде.

  

Для примера, давайте создадим страницу `index.js`:

  

```jsx

// pages/index.js

  
import  React, { useState, useEffect } from  'react';

  
export  default  function  Home() {
	const [data, setData] = useState([]);

	useEffect(() => {
		async  function  fetchData() {
			const  response = await  fetch('/api/api');
			const  result = await  response.json();
			setData(result);
		}
		fetchData();
	}, []);

  
	return (
		<div>
			<h1>Данные с бэкенда:</h1>
			<ul>
				{data.map((item) => (
					<li  key={item.id}>{item.name}</li>
				))}
			</ul>
		</div>
	);
}
```

  

Этот компонент получает данные с нашего бэкенда через API эндпоинт `/api/api` и отображает их в виде списка на главной странице.

#### 5.3. Пример вывода заказов по профилю

#### /store/index.js - клиентское хранилище valtio

```javascript
import { proxy } from 'valtio';

export const store = proxy({
  orders: [],
  loading: false,
});
```

#### /service/profile.js - бизнеслогика 

```javascript
import { store } from '../store';
import { fetchOrders } from '../actions/profile';

export const fetchUserOrders = async (userId) => {
  try {
    store.loading = true;
    const orders = await fetchOrders(userId);
    store.orders = orders;
  } catch (error) {
    console.error('Failed to fetch orders:', error);
  } finally {
    store.loading = false;
  }
};
```

##### /actions/profile.js - запросы axios

```javascript
import axios from 'axios';

export const fetchOrders = async (userId) => {
  try {
    const response = await axios.get(`/api/orders?userId=${userId}`);
    return response.data;
  } catch (error) {
    throw new Error('Failed to fetch orders');
  }
};
```

##### /app/profile/page.js - вывод всех заказов

```javascript
import { useEffect } from 'react';
import { useSnapshot } from 'valtio';
import { store } from '../../store';
import { fetchUserOrders } from '../../service/profile';

const ProfilePage = ({ userId }) => {
  const { orders, loading } = useSnapshot(store);

  useEffect(() => {
    fetchUserOrders(userId);
  }, [userId]);

  return (
    <div>
      <h1>Profile Page</h1>
      {loading ? (
        <p>Loading...</p>
      ) : (
        <ul>
          {orders.map((order) => (
            <li key={order.id}>{order.product_name}</li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default ProfilePage;
```

Чтобы протестировать работу приложения, можно выполнить следующие шаги:

1. **Запуск сервера Next.js**: Убедитесь, что сервер Next.js запущен локально. Выполните команду `npm run dev` или `yarn dev` в корневой директории проекта Next.js.

3. **Открытие страницы профиля в браузере**: Откройте браузер и перейдите на страницу профиля, которая обычно доступна по адресу `http://localhost:3000/profile` 

4. **Проверка загрузки данных**: Убедитесь, что данные заказов успешно загружаются и отображаются на странице профиля. Если данные не отображаются, проверьте консоль браузера на наличие ошибок и убедитесь, что все запросы к API выполняются правильно.

5. **Тестирование функциональности**: Попробуйте выполнить различные действия на странице профиля, такие как обновление данных заказов или изменение параметров запросов. Убедитесь, что приложение ведет себя корректно и отображает ожидаемые результаты.

После завершения этих шагов вы можете быть уверены, что ваше приложение работает корректно и готово к использованию.


#### 5.4. Запуск проекта

  

Теперь мы можем запустить наш проект Next.js с помощью команды:

  

```bash

npm  run  dev

```

  

После этого вы сможете открыть браузер и перейти по адресу `http://localhost:3000`, чтобы увидеть ваше приложение в действии.

  

### Глава 6. Тестирование и отладка

  

В этой главе мы рассмотрим основные аспекты тестирования и отладки приложения. Мы углубимся в процесс проверки работоспособности API, взаимодействия компонентов на фронтенде и анализа логов для выявления и устранения ошибок.

  

#### 6.1. Тестирование API

  

Для тестирования API мы будем использовать инструменты, позволяющие отправлять запросы на наши эндпоинты и проверять полученные ответы. Один из таких инструментов - `curl`.

  

Пример тестирования эндпоинта `/profile/{profile_id}` для получения информации о профиле:

  

```bash

curl  http://localhost:8000/profile/1

```

  

Ожидаемый результат: JSON-объект с информацией о профиле с `profile_id` равным 1.

  

#### 6.2. Тестирование компонентов на фронтенде

  

Для тестирования компонентов на фронтенде мы можем использовать различные фреймворки и библиотеки, такие как Jest, React Testing Library, Enzyme и другие, в зависимости от используемых технологий.

  

Пример тестирования React-компонента `<Profile />`:

  

```jsx

import  React  from  'react';
import { render, screen } from  '@testing-library/react';
import  Profile  from  './Profile';

  

test('renders profile information', () => {
	render(<Profile  />);
	const  linkElement = screen.getByText(/Profile Information/i);
	expect(linkElement).toBeInTheDocument();
});

```

  

#### 6.3. Анализ логов

  

Для анализа логов мы можем использовать различные инструменты и библиотеки, например, Loguru для Python или Elastic Stack (Elasticsearch, Logstash, Kibana). В данном примере рассмотрим использование Loguru для записи логов в файл.

  

Пример использования Loguru для записи логов:

  

```python

from loguru import logger

  
logger.add("app.log", rotation="500 MB")


def  some_function():
	try:
		# Some code that may raise an exception
		pass
		except  Exception  as e:
		logger.error(f"An error occurred: {e}")

```

  

### Глава 7. Завершение работы

  

#### 7.1. Коммит и пуш изменений в созданную ветку Git

  

После завершения работы над проектом необходимо зафиксировать внесенные изменения и отправить их в репозиторий Git. Для этого используются следующие команды:

  

```bash

# Добавление всех измененных файлов в индекс Git
git  add  .

# Фиксация изменений с комментарием
git  commit  -m  "Описание проделанной работы"

# Отправка изменений на удаленный репозиторий (origin) и в созданную ветку
git  push  origin <название_ветки>

```

  

#### 7.2. Описание процесса деплоя проекта и внесенных изменений

  

При подготовке к деплою проекта необходимо убедиться, что все изменения были зафиксированы и отправлены в репозиторий. Затем процесс деплоя может включать в себя следующие шаги:

  

#### 7.2.1. Настройка среды разработки и деплоя

  

- Проверка наличия всех необходимых зависимостей и инструментов на сервере или платформе хостинга.

- Установка и настройка Docker и Docker Compose для контейнеризации приложения.

- Создание и настройка конфигурационных файлов для окружений разработки, тестирования и продакшн.

  

#### 7.2.2. Создание Docker образов

  

- Настройка Dockerfile для сборки образа приложения.

- Сборка Docker образа с помощью команды `docker build`.

- Запуск контейнера с созданным образом и проверка его работоспособности локально.

  

#### 7.2.3. Настройка CI/CD

  

- Настройка Continuous Integration (CI) для автоматической сборки и тестирования кода при каждом обновлении в репозитории.

- Настройка Continuous Deployment (CD) для автоматического деплоя приложения на сервер или платформу хостинга после успешного прохождения всех тестов в CI.

  

#### 7.3. Предоставление рекомендаций по тестированию и обслуживанию развернутой версии приложения

  

После успешного развертывания приложения необходимо обеспечить его стабильную работу и обслуживание. Для этого можно рекомендовать следующие действия:

  

- Регулярное проведение тестирования приложения на соответствие функциональным требованиям.

- Мониторинг производительности и надежности приложения с использованием специализированных инструментов.

- Внесение обновлений и исправлений по мере необходимости для поддержания актуальности и безопасности приложения.

- Резервное копирование данных и настройка механизмов восстановления в случае сбоев или потери информации.

  

### 3. **FAQ. Дерево решений**

  

#### Компьютерные проблемы

  

1. У меня возникла ошибка в коде. Что делать?

- Проверьте логи ошибок (если есть) и попробуйте разобраться в причинах возникновения ошибки.

- Обратитесь к документации или сообществу разработчиков для поиска решения проблемы.

- Проверьте свой код на наличие синтаксических ошибок или несоответствия требованиям языка программирования.

  

2. Как решить проблему с подключением к базе данных?

- Убедитесь, что данные для подключения указаны корректно в конфигурационном файле.

- Проверьте доступность и состояние сервера базы данных.

- Попробуйте выполнить тестовый запрос к базе данных для проверки соединения.

  

#### Проблемы с проектом

  

1. Как добавить новый функционал в проект?

- Ознакомьтесь с требованиями к новому функционалу.

- Создайте отдельную ветку для разработки нового функционала.

- Напишите код согласно заданным требованиям.

- Протестируйте новый функционал перед объединением с основной веткой проекта.

  

2. Что делать, если мой код не проходит ревью?

- Внимательно изучите замечания и рекомендации ревьювера.

- Внесите необходимые исправления в код.

- Попробуйте обсудить проблемные моменты с ревьювером для лучшего понимания требований.

  

#### Коммуникационные вопросы

  

1. Как правильно общаться с коллегами?

- Старайтесь быть вежливым и уважительным в общении.

- Задавайте вопросы четко и конкретно, описывая проблему или задачу.

- Помогайте коллегам, если у вас есть возможность, и просите помощи, когда вам нужна поддержка.

  

2. Как решить конфликтную ситуацию с коллегой?

- Попробуйте выяснить причины конфликта и найти компромиссное решение.

- Обсудите проблему с коллегой лично и в спокойной обстановке.

- При необходимости обратитесь к руководству или HR-отделу для помощи в разрешении конфликта.

  

#### Вопросы по процессу разработки

  

1. Какие инструменты использовать для разработки и отладки кода?

- Используйте среды разработки (IDE) такие как PyCharm, WebStorm для написания кода.

- Для отладки кода используйте инструменты отладки, предоставляемые вашей IDE.

  

2. Как организовать работу с Git и контролем версий?

- Создайте отдельную ветку для каждой задачи или новой функциональности.

- Регулярно коммитте и пушьте изменения в удаленный репозиторий.

- Используйте функционал ветвления и слияния для организации рабочего процесса.

  

#### Технические вопросы

  

1. Как оптимизировать производительность приложения?

- Используйте кэширование данных и оптимизацию запросов к базе данных.

- Оптимизируйте код приложения, устраняя узкие места и избегая лишних запросов.

  

2. Как обеспечить безопасность приложения?

- Используйте HTTPS для защиты передачи данных между клиентом и сервером.

- Внедрите механизмы аутентификации и авторизации пользователей.

- Проводите регулярные аудиты безопасности приложения и исправляйте обнаруженные уязвимости.

  

#### Вопросы по тестированию

  

1. Как написать и запустить тесты для моего кода?

- Используйте фреймворки для тестирования, такие как pytest для Python.

- Напишите модульные тесты для проверки отдельных компонентов вашего кода.

- Запустите тесты с помощью специальных команд или интегрированных инструментов в вашей среде разработки.

  

2. Как автоматизировать процесс тестирования?

- Настройте Continuous Integration (CI) для автоматического запуска тестов при каждом обновлении кода.

- Используйте инструменты для автоматизации тестирования, такие как Selenium для автоматизации тестирования веб-приложений.

  

#### Вопросы по интеграции

  

1. Как интегрировать различные компоненты приложения?

- Используйте стандартные протоколы и форматы данных для взаимодействия между компонентами приложения.

- Напишите API-методы для обмена данными между серверной и клиентской сторонами приложения.

  

2. Как настроить взаимодействие с внешними сервисами и API?

- Ознакомьтесь с документацией по внешним сервисам и API для понимания методов взаимодействия.

- Используйте библиотеки или SDK для упрощения интеграции с внешними сервисами.

- Проведите тестирование интеграции для проверки корректности работы приложения с внешними сервисами.
